<!DOCTYPE html>
<html
  lang="en"
  dir="ltr"
  
><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Java-Concurrent | 春江花朝秋月夜</title>

<meta name="generator" content="Hugo Eureka 0.9.3" />
<link rel="stylesheet" href="/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css">
<script defer src="/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js"></script>













<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto&#43;Serif&#43;SC:wght@400;600;700&amp;display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"
   crossorigin></script>
  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js"
     crossorigin></script>
<link rel="stylesheet" href="/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css" media="print" onload="this.media='all';this.onload=null">


<script defer type="text/javascript" src="/js/fontawesome.min.f14def4f6943de5b19b19c02e239b98c8cc6a8fe66b6828a21da7c0e9d405df8364cab68aa637c3bbe735eb7c325aa3c.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
   integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" 
  integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
   integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js" 
  integrity="sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0"  crossorigin></script>


<link rel="icon" type="image/png" sizes="32x32" href="/img/author_hu46370d4ccd3481872546da16224d0daa_1972225_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="/img/author_hu46370d4ccd3481872546da16224d0daa_1972225_180x180_fill_box_center_3.png">

<meta name="description"
  content="并发编程基础">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Las",
      "item":"/la/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Java-Concurrent",
      "item":"/la/java/%E5%B9%B6%E5%8F%91/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/la/java/%E5%B9%B6%E5%8F%91/"
    },
    "headline": "Java-Concurrent | 春江花朝秋月夜",
    "image": "/la/java/%E5%B9%B6%E5%8F%91/featured.png",
    "datePublished": "2023-10-09T19:49:34+08:00",
    "dateModified": "2023-10-09T19:49:34+08:00",
    "wordCount":  551 ,
    "publisher": {
        "@type": "Person",
        "name": "春江花朝秋月夜",
        "logo": {
            "@type": "ImageObject",
            "url": "/img/author.png"
        }
        },
    "description": "并发编程基础"
}
</script><meta property="og:title" content="Java-Concurrent | 春江花朝秋月夜" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/img/author.png">


<meta property="og:url" content="/la/java/%E5%B9%B6%E5%8F%91/" />



<meta property="og:description" content="并发编程基础" />



<meta property="og:locale" content="en" />




<meta property="og:site_name" content="春江花朝秋月夜" />






<meta property="article:published_time" content="2023-10-09T19:49:34&#43;08:00" />


<meta property="article:modified_time" content="2023-10-09T19:49:34&#43;08:00" />



<meta property="article:section" content="la" />


<meta property="article:tag" content="并发编程" />






  <body class="flex min-h-screen flex-col">
    <header
      class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"
    >
      <div class="mx-auto w-full max-w-screen-xl"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="me-6 text-primary-text text-xl font-bold">春江花朝秋月夜</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/tags/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">标签</a>
            <a href="/la/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">笔记</a>
            <a href="/info" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">关于</a>
            <a href="/friend/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">朋友</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
    </header>
    <main class="grow pt-16">
        <div class="pl-scrollbar">
          <div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8">
  
  
  <div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12">
    <div
      class="lg:col-start-2 bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
    >
      <article class="prose">
  <h1 class="mb-4">Java-Concurrent</h1>

  <div
  class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"
>
  <div class="me-6 my-2">
    <i class="fas fa-calendar me-1"></i>
    <span
      >2023-10-09</span
    >
  </div>
  <div class="me-6 my-2">
    <i class="fas fa-clock me-1"></i>
    <span>3 min read</span>
  </div>

  

  
</div>


  
  
    <img src="/la/java/%E5%B9%B6%E5%8F%91/featured.png" class="w-full" alt="Featured Image">
  

  <h1 id="java-并发编程">Java 并发编程</h1>
<h3 id="轻量级锁">轻量级锁：</h3>
<p>检查当前对象的mark word是否有被其他线程占用，假如没有就会在当前栈帧里面建立一个
锁记录，复制并存储当前对象的mark word 信息。</p>
<p>不像重量级锁需要向系统申请互斥量，</p>
<h3 id="cas无锁算法">CAS（无锁算法）</h3>
<p><img src="juc/img_3.png" alt="img_3.png"></p>
<p>显然，当cas失败的时候，说明有线程进入了这个同步代码块，这个时候，虚拟机将会检查
当前对象的mark word是否指向当前对象的栈帧，是的话就说明当前已经获得锁，否则不是-》退化为重量级锁(不可逆)
解锁时，同样使用CAS算法操作，同时唤醒挂起的线程</p>
<h3 id="偏向锁">偏向锁</h3>
<p>当某个锁频繁的被同一个线程获取，对轻量级锁进行优化，所以偏向锁专门为单个线程服务，此时，无须再进行CAS操作，当其他线程
又开始抢锁，偏向锁可能退化为轻量级锁。注意当调用对象的hashCode（）方法，由于mark word 数据结构无法
保存hash值，偏向锁直接退化为轻量级锁。</p>
<p><b> 锁的退化不可逆</b></p>
<h3 id="锁消除和锁优化">锁消除和锁优化</h3>
<p>代码块中有可能不会总是出现请求锁和释放锁的问题，（比如循环中加锁），此时锁为了优化出现锁消除和锁优化</p>
<h2 id="java内存模型jmm">Java内存模型（JMM）</h2>
<p><img src="juc/img_6.png" alt="img_6.png"></p>
<p>主内存： 存放对象实例的部分
工作内存：虚拟机栈的部分，放入cpu的高速缓存里面。 自增操作不是由一个指令实现的！！！包括获取，修改和保存</p>
<pre><code class="language-java">class Test{
  private static volatile int sum=0;//成员变量,这样的变量必须是当前的对象所拥有的
  //加入了volatile关键字之后，线程之间可以感知彼此的值
  @Test
  void LockTestAdd() throws InterruptedException {
    //没有加锁的时候，由于线程之间不能感知对方的值，最终结构可能不会是200
    Thread th1 = new Thread(() -&gt; {
      for (int i = 0; i &lt; 100; i++)
        sum++;
    });

    Thread th2 = new Thread(() -&gt; {
      for (int i = 0; i &lt; 100; i++)
        sum++;
    });
    th1.start();
    th2.start();
    Thread.sleep(100);
    System.out.println(sum);
  }
}
</code></pre>
<h3 id="重排序">重排序</h3>
<p>由于JVM虚拟机和编译器的优化，指令可能出现重排序，在这种情况下可能出现不符合预期的情况</p>
<h3 id="volatile关键字无法保证原子性但能保证可见性">volatile关键字（无法保证原子性，但能保证可见性）</h3>
<p><img src="juc/img_7.png" alt="img_7.png"></p>
<p>load和save操作，将主内存中的变量拷贝到本地，只对本地变量进行操作。</p>
<p>volatile实现原理就是改变成员变量时，save的工作区的变量无效。重新更新主内存中的变量值，
volatile关键字会禁止指令重排序。</p>
<p><img src="juc/img_8.png" alt="img_8.png"></p>
<pre><code class="language-java">class VolatileTest{
  
private static volatile int sum=0;//成员变量,这样的变量必须是当前的对象所拥有的
    //加入了volatile关键字之后，线程之间可以感知彼此的值,但还是无法保证原子性操作，不能达到预期效果
    @Test
    void LockTestAdd() throws InterruptedException {
        //没有加锁的时候，由于线程之间不能感知对方的值，最终结构可能不会是200
        Thread th1 = new Thread(() -&gt; {
            for (int i = 0; i &lt; 1000; i++)
                    sum++;
        });
       Thread th2 = new Thread(() -&gt; {
            for (int i = 0; i &lt; 1000; i++) {
                sum++;
            }
        });
        th1.start();
        th2.start();
        Thread.sleep(100);
        System.out.println(sum);
    }
}

</code></pre>
<p>JVM编译器下面的顺序执行：</p>
<h3 id="happens-before-原则之前的对之后的可见">Happens Before 原则（之前的对之后的可见）</h3>
<p>程序次序规则，监视器锁原则，volatile关键字原则（写操作在读操作之前），</p>
<h4 id="start线程启动规则">start(线程启动规则)</h4>
<p>A线程用start调用B线程，那么A在B之前（A happens before B）</p>
<h4 id="join线程加入规则">join线程加入规则</h4>
<p>A线程join线程B，那么B在A之前（B happens before A）</p>
<h4 id="程和线程的区别">程和线程的区别</h4>
<p>程序软件 &gt; 进程 &gt; 线程</p>
<h3 id="锁的框lock">锁的框：Lock</h3>
<p>为了代替传统的synchronized,notify,wait,notifyAll关键字，Lock接口-&gt;ReentrantLock可重入锁</p>
<p><img src="juc/img_9.png" alt="img_9.png"></p>
<h2 id="可重入锁排他锁">可重入锁（排他锁）</h2>
<p>多次加锁，其他线程想要得到锁需要把多次的锁释放才可以获取这把锁</p>
<p>当存在线程想要获取锁但是锁没有释放的时候，此时这些线程将会进入线程队列里面</p>
<h3 id="公平锁和非公平锁aqs">公平锁和非公平锁（AQS）</h3>
<p><img src="juc/img_10.png" alt="img_10.png"></p>
<p>公平锁始终保持先到先得到锁，非公平锁则是在等待队列中所有等待线程同时尝试获取锁，获取不到则再次进入等待队列</p>
<pre><code class="language-txt">ReentrantLock lock=new ReentrantLock(false);//公平锁不一定总是保持公平。队列同步器
        Runnable runnable=()-&gt;{
            System.out.println(Thread.currentThread().getName() + &quot;开始尝试获取锁资源&quot;);
            lock.lock();

            System.out.println(Thread.currentThread().getName() + &quot;成功😺😺😺😺😺😺😺😺😺获取锁资源&quot;);
            lock.unlock();
        };

        for (int i = 0; i &lt; 10; i++) {
            new Thread(runnable,&quot;T&quot;+i).start();
        }
</code></pre>
<h3 id="读写锁">读写锁：</h3>
<blockquote>
<p>除了可重入锁之外，还有一种类型的锁叫做读写锁，当然它并不是专门用作读写操作的锁，
它和可重入锁不同的地方在于，可重入锁是一种排他锁，当一个线程得到锁之后，另一个线程必须等待其释放锁，否则一律不允许获取到锁。而读写锁在同一时间，是可以让多个线程获取到锁的，它其实就是针对于读写场景而出现的。</p>
<p>读写锁维护了一个读锁和一个写锁，这两个锁的机制是不同的。</p>
<p>读锁：在没有任何线程占用写锁的情况下，同一时间可以有多个线程加读锁。</p>
<p>写锁：在没有任何线程占用读锁的情况下，同一时间只能有一个线程加写锁。</p>
</blockquote>
<p>显然读锁是可以重复获取的但是写锁不能，当一个线程同时拥有写锁和读锁的时候，先申请读锁
然后释放写锁，此时其他的线程又可以获取读锁，只剩下读锁，此时称之为“锁降级”。
在仅仅持有读锁的时候去申请写锁，称为“锁升级”，这时候ReentryReadWriteLock类不支持。</p>
<h3 id="队列同步器aqsabstractqueuedsynchronizer">队列同步器AQS（AbstractQueuedSynchronizer）</h3>
<p>继承关系：Lock-&gt; Sync -&gt; AbstractQueuedSynchronizer</p>
<h3 id="多线程并发环境下的aba问题">多线程并发环境下的ABA问题</h3>
<pre><code class="language-java">//ABA问题的版本号解决方法
        AtomicReference&lt;String&gt; atomicReference=new AtomicReference&lt;&gt;(&quot;A&quot;);
        System.out.println(atomicReference.compareAndSet(&quot;a&quot;, &quot;c&quot;));
        String hello = &quot;hello&quot;;
        String world = &quot;world&quot;;

        Runnable r=()-&gt;{
            System.out.println(atomicReference.compareAndSet(&quot;A&quot;, &quot;B&quot;));
        };
        for (int i = 0; i &lt; 100; i++) {
            new Thread(r).start();
        }
</code></pre>
<p>可以看到多个线程尝试去修改的时候出现了一个true</p>
<p>解决办法：添加版本号，每次修改的时候对版本号（stamp）进行修正</p>
<h2 id="并发容器">并发容器</h2>
<p>比如在对链表添加元素的时候，还没有完成对链表扩容之前，其他线程插队，非法插入元素，就会造成数组越界的报错。</p>
<ul>
<li>ConcurrentHashMap:在jdk1.7之前的实现方法，比如在原子类里面实现LongAdder具有压力分散的思想，提高了性能，选择将数据一段一段的存储，这样就减少了等待，当线程访问锁的时候只占用锁的一小部分</li>
<li>jdk8之后，实现方法是通过cas算法配合锁机制实现的。由于HashMap利用了哈希表，容量越大，加锁的粒度就会越细。</li>
</ul>
<pre><code class="language-java">//原子类的测试操作
        //ABA问题的版本号解决方法
        CopyOnWriteArrayList&lt;Object&gt; objects = new CopyOnWriteArrayList&lt;&gt;();
        //读取不加锁，写数据需要加锁，所以性能还行
        //专用于多线程环境下的容器
        LinkedList&lt;Object&gt; list = new LinkedList&lt;&gt;();//没有发生并发异常
        ArrayList&lt;Object&gt; list1 = new ArrayList&lt;&gt;();
        ConcurrentHashMap&lt;Integer, String&gt; map = new ConcurrentHashMap&lt;&gt;();
        HashMap&lt;Integer, String&gt; hashMap = new HashMap&lt;&gt;();
        Runnable r=()-&gt;{
            for (int j = 0; j &lt; 100; j++) {
                int finalI=j;
                objects.add(&quot;aaa&quot;);
                map.put(finalI,&quot;aaa&quot;);
                hashMap.put(finalI,&quot;aaa&quot;);
            }
        };
        for (int i = 0; i &lt; 100; i++) {
            new Thread(r).start();
        }
        TimeUnit.SECONDS.sleep(1);
</code></pre>
<h3 id="阻塞队列blokingqueue">阻塞队列（BlokingQueue）</h3>
<p>生产者消费之模型：</p>
<pre><code class="language-java"> //测试阻塞队列实现生产者消费者模型
        BlockingQueue&lt;Object&gt; queue=new ArrayBlockingQueue&lt;&gt;(1);//窗口只能放一个菜，阻塞队列的容量
        Runnable supplier=()-&gt;{
          while (true){
              try {
                  String name = Thread.currentThread().getName();
                  System.err.println(time()+&quot;生产者&quot;+name+&quot;正在准备餐品&quot;);
                  TimeUnit.SECONDS.sleep(3);
                  System.err.println(time()+&quot;生产者&quot;+name+&quot;已出餐&quot;);
                  queue.put(new Object());
              }catch (InterruptedException e){
                  e.printStackTrace();
                  break;
              }
          }
        };

        Runnable consumer=()-&gt;{
            while (true){
                try {
                    String name = Thread.currentThread().getName();
                    System.out.println(time()+&quot;消费者&quot;+name+&quot;正在等待餐品&quot;);
                    queue.take();
                    System.out.println(time()+&quot;消费者&quot;+name+&quot;已取餐&quot;);
                    TimeUnit.SECONDS.sleep(4);
                    System.out.println(time()+&quot;消费者&quot;+name+&quot;已吃完&quot;);
                }catch (InterruptedException e){
                    e.printStackTrace();
                    break;
                }
            }
        };
        for (int i = 0; i &lt; 2; i++) {
            new Thread(supplier,&quot;supplier&quot;+i).start();
        }
        for (int i = 0; i &lt; 3; i++) {
            new Thread(consumer,&quot;consumer&quot;+i).start();
        }
    }
    public static String time(){
        SimpleDateFormat format = new SimpleDateFormat(&quot;HH:mm:ss&quot;);
        return &quot;[&quot;+format.format(new Date())+&quot;]&quot;;
    }
</code></pre>
<p>常见的阻塞队列：ArrayBlokingQueue(有界缓冲阻塞队列),SynchronousQueue(无缓冲阻塞队列),LinkedBlokingQueue(无界带缓冲阻塞队列)</p>
<pre><code class="language-java">public boolean offer(E e) {
        Objects.requireNonNull(e);//检查当前的队列是否为空
        final ReentrantLock lock = this.lock;//对当前线程加锁
        lock.lock();
        try {
            if (count == items.length)
                return false;
            else {
                enqueue(e);
                return true;
            }
        } finally {
            lock.unlock();
        }
    }
</code></pre>
<pre><code class="language-java">public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0)
                notEmpty.await();//当当前线程读取到队列为空时，由于take操作时阻塞的，需要挂起当前线程，等待直到队列里面有值
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
</code></pre>
<h4 id="synchronousqueue没有任何容量插入和取出是一一对应的">SynchronousQueue(没有任何容量，插入和取出是一一对应的)</h4>
<pre><code class="language-java">SynchronousQueue&lt;String&gt; queue=new SynchronousQueue&lt;&gt;();
        new Thread(()-&gt;{
            try {
                System.out.println(queue.take());
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }).start();
        queue.put(&quot;sss&quot;);
</code></pre>
<p>这是一个特殊的队列，内部维护了一个抽象类Transfer（put和take操作糅合在一起了），
里面有一个方法：transfer（E e,bolean timed,long nanos）直接通过生产者和消费者模型来实现数据的传递。
当新的元素put进去线程将会阻塞。直到元素被take。同时这个类维护了公平锁和非公平锁两种方法。</p>
<blockquote>
<p><img src="juc/tansfer.png" alt="image.png"></p>
</blockquote>
<p>当当前队列里面有元素但是没有线程来取元素时候，就会开启自旋，当自旋一定次数之后还没有来取就会挂起</p>
<h5 id="priorityblockingqueue优先队列">PriorityBlockingQueue优先队列</h5>
<p>构造方法：PriorityQueue<Integer> queue=new PriorityQueue<Integer>(10,Integer::compare);</p>
<p>传入容量和函数逻辑（优先逻辑）</p>
<h4 id="delayqueue延时队列">DelayQueue延时队列</h4>
<p>特殊地方：存储的元素必须是继承自Delayed接口的类，同时元素类必须实现Delayed接口。</p>
<p>使用时可以实现延时出队，按照同时的时候按照优先级（自己实现）进行出队，这样就可以实现缓存了。</p>
<p>底层实现：</p>
<pre><code class="language-java">  public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt;
        implements BlockingQueue&lt;E&gt; {
    private final transient ReentrantLock lock = new ReentrantLock();
    private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();  //通过内部维护的优先队列来实现元素的存储，而不是本身进行存储
}
</code></pre>
<h4 id="主要常见的阻塞队列总结如下">主要常见的阻塞队列总结如下：</h4>
<ul>
<li>ArrayBlokingQueue底层通过数组实现的阻塞队列，可以设置初始的容量，换句话容量是固定的</li>
<li>LinkedTransferQueue</li>
<li>SynchronousQueue要求入队和出队必须同时进行，一一对应，原因是内部维护了一个抽象类tansfer，需要等到消费者和生产者同时到齐才可以完成交接工作，支持公平和非公平</li>
<li>PriorityBlokingQueue优先队列，元素的获取顺序按照优先级决定</li>
<li>DelayQueue能够实现延迟获取元素，同样支持优先级，要求加入的元素必须继承Delayed接口</li>
</ul>
<h3 id="数据字典">数据字典</h3>
<p>常见的常用的数据，具有分级的特点，现在将比如省份县市地点的信息维护成一张表就可以是实现
据字典，通常具有id，parent_id这些字段，维护父级和子级的关系。</p>
<p>关于ElementUi的数据字典的显示方法就是检查hasChildren字段的值进行渲染</p>
<h3 id="线程池">线程池</h3>
<p>引入原因：频繁创建和销毁线程对系统资源的浪费十分严重，为了合理分配和调用系统资源，产生了线程池的技术</p>
<p>实现原理：将已创建的线程复用，利用池化技术，就像数据库连接池一样，我们也可以创建很多个线程，然后反复地使用这些线程，而不对它们进行销毁。</p>
<p>由于线程池可以反复利用已有线程执行多线程操作，所以它一般是有容量限制的，当所有的线程都处于工作状态时，那么新的多线程请求会被阻塞，直到有一个线程空闲出来为止，实际上这里就会用到我们之前讲解的阻塞队列。</p>
<p><img src="juc/ThreadPool.png" alt="image.png"></p>

</article>


      
        <div class="my-4">
    
    <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#并发编程</a>
    
</div>
      

      



      

      
  <div
    class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"
  >
    <div>
      
        <span class="text-primary-text block font-bold"
          >Previous</span
        >
        <a href="/la/java/%E8%BF%9B%E9%98%B6/" class="block">并发进阶</a>
      
    </div>
    <div class="mt-4 md:mt-0 md:text-right">
      
        <span class="text-primary-text block font-bold">下一篇</span>
        <a href="/la/%E6%9D%82%E8%AE%B0/" class="block">科学上网</a>
      
    </div>
  </div>


      



    </div>
    

    
    
  </div>

  
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
      });
    </script>

          </div>
        </div>
      
    </main>
    <footer class="pl-scrollbar">
      <div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2023 <a href="https://todreamr.github.com/">春江花朝秋月夜</a> and <a href="https://www.ruiqima.com/">MA Ruiqi</a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
    </footer>
  </body>
</html>
